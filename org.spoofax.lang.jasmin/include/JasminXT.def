definition
module JasminXT-Directives

imports
	
	lexical/JasminXT-Numbers
	lexical/JasminXT-Descriptors
	
exports
	
	context-free syntax
		
		".limit" "stack" Int 	-> Directive {cons("JBCLimitStack")}		
		".limit" "locals" Int -> Directive {cons("JBCLimitLocals")}	
		".line" Int						-> Directive {cons("JBCLine")}
		".throws" ClassRef		-> Directive {cons("JBCThrows")}
		
		".catch" ClassRef "from" LabelRef "to" LabelRef "using" LabelRef 			-> Directive {cons("JBCCatch")}
		".var" Int "is" VarName FieldDescriptor "from" LabelRef "to" LabelRef -> Directive {cons("JBCVarDecl")}
		
	lexical restrictions
		
		".limit" 
		"stack" 
		"locals" 	
		".line" 
		".throws" 
		".catch" 
		"from" 
		"to" 
		"using" 
		".var" 
		"is" 
		"from"
		"to" 	-/- ~[\ \t]

module instructions/JasminXT-Synchronisation

exports

	context-free syntax
		
		"monitorenter" -> Instruction {cons("MONITORENTER")}
		"monitorexit"  -> Instruction {cons("MONITOREXIT")}

module instructions/JasminXT-Exceptions

exports

	context-free syntax
		
		"athrow" -> Instruction {cons("ATHROW")}

module instructions/JasminXT-Methods

imports
	lexical/JasminXT-Names
	lexical/JasminXT-Descriptors
	
exports
	context-free syntax
				
		"invokenonvirtual" MethodRef			-> Instruction {cons("INVOKESPECIAL")}
		"invokevirtual"    MethodRef 			-> Instruction {cons("INVOKEVIRTUAL")}
		"invokestatic"     MethodRef			-> Instruction {cons("INVOKESTATIC")}
		"invokeinterface"  MethodRef Int	-> Instruction {cons("INVOKEINTERFACE")}
		
		"return"  -> Instruction {cons("RETURN")}   
		"ireturn" -> Instruction {cons("IRETURN")} 
		"lreturn" -> Instruction {cons("LRETURN")} 
		"freturn" -> Instruction {cons("FRETURN")} 
		"dreturn" -> Instruction {cons("DRETURN")} 
		"areturn" -> Instruction {cons("ARETURN")} 

	lexical restrictions
		
		"invokenonvirtual"
		"invokevirtual"
		"invokestatic"
		"invokeinterface" -/- ~[\ \t]

module instructions/JasminXT-Control

imports
	lexical/JasminXT-Names
	lexical/JasminXT-Numbers
	
exports
	
	context-free syntax
		
		Int				-> LabelRef  {cons("Absolute")}
		"$+" Int	-> RelOffset {cons("RelativeFwd")}
		"$-" Int	-> RelOffset {cons("RelativeBwd")}
		
		LabelRef	-> Target
		RelOffset	-> Target
		
	context-free syntax
		
		"ifeq" Target 			-> Instruction {cons("IFEQ")} 
		"iflt" Target 			-> Instruction {cons("IFLT")} 
		"ifle" Target	 			-> Instruction {cons("IFLE")} 
		"ifne" Target 			-> Instruction {cons("IFNE")} 
		"ifgt" Target 			-> Instruction {cons("IFGT")} 
		"ifge" Target		 		-> Instruction {cons("IFGE")} 
		"ifnull" Target 		-> Instruction {cons("IFNULL")} 
		"ifnonnull" Target 	-> Instruction {cons("IFNONNULL")} 
		"if_icmpeq" Target 	-> Instruction {cons("IF_ICMPEQ")} 
		"if_icmplt" Target 	-> Instruction {cons("IF_ICMPLT")} 
		"if_icmple" Target 	-> Instruction {cons("IF_ICMPLE")} 
		"if_icmpne" Target 	-> Instruction {cons("IF_ICMPNE")} 
		"if_icmpgt" Target 	-> Instruction {cons("IF_ICMPGT")} 
		"if_icmpge" Target 	-> Instruction {cons("IF_ICMPGE")} 
		"if_acmpeq" Target 	-> Instruction {cons("IF_ACMPEQ")} 
		"if_acmpne" Target 	-> Instruction {cons("IF_ACMPNE")} 
		
		"tableswitch"  Int TableEntry*  "default" ":" LabelRef -> Instruction {cons("Table")}
		"lookupswitch"     LookupEntry* "default" ":" LabelRef -> Instruction {cons("Lookup")}
		
		LabelRef         -> TableEntry {cons("Jump")}
		Int ":" LabelRef -> LookupEntry {cons("NPAIR")}
		
  	"goto" LabelRef   -> Instruction {cons("GOTO")}
		"goto_w" LabelRef -> Instruction {cons("GOTO_W")}
			
	lexical restrictions
		
		"ifeq" 
		"iflt" 
		"ifle" 
		"ifne" 
		"ifgt" 
		"ifge" 
		"ifnull" 
		"ifnonnull" 
		"if_icmpeq" 
		"if_icmplt" 
		"if_icmple" 
		"if_icmpne" 
		"if_icmpgt" 
		"if_icmpge" 
		"if_acmpeq" 
		"if_acmpne"
		"tableswitch"
		"goto" 	
		"goto_w"		-/- ~[\ \t]

module instructions/JasminXT-Stack

exports
	
	context-free syntax
		
		"pop"     -> Instruction {cons("POP")}
		"pop2"    -> Instruction {cons("POP2")}    
		"dup"     -> Instruction {cons("DUP")}
		"dup2"    -> Instruction {cons("DUP2")}
		"dup_x1"  -> Instruction {cons("DUP_X1")}
		"dup2_x1" -> Instruction {cons("DUP2_X1")}
		"dup_x2"  -> Instruction {cons("DUP_X2")}
		"dup2_x2" -> Instruction {cons("DUP2_X2")}
		"swap"    -> Instruction {cons("SWAP")}

module instructions/JasminXT-Objects

imports
	
	lexical/JasminXT-Names
	lexical/JasminXT-Numbers
	lexical/JasminXT-Descriptors
	
exports
	context-free syntax
		
		"new" ClassRef -> Instruction {cons("NEW")}
		
		"newarray"       BaseTypeName 	-> Instruction {cons("NEWARRAY")}
		"anewarray"      ClassRef				-> Instruction {cons("ANEWARRAY")}
		"anewarray"      ArrayType			-> Instruction {cons("ANEWARRAY")}
		"multianewarray" ArrayType Int	-> Instruction {cons("MULTIANEWARRAY")}

		"getfield"  FieldRef -> Instruction {cons("GETFIELD")}
		"putfield"  FieldRef -> Instruction {cons("PUTFIELD")}
		"getstatic" FieldRef -> Instruction {cons("GETSTATIC")}
		"putstatic" FieldRef -> Instruction {cons("PUTSTATIC")}
	
		"iaload" -> Instruction {cons("IALOAD")}
		"laload" -> Instruction {cons("LALOAD")}
		"baload" -> Instruction {cons("BALOAD")}
		"caload" -> Instruction {cons("CALOAD")}
		"saload" -> Instruction {cons("SALOAD")}
		"faload" -> Instruction {cons("FALOAD")}
		"daload" -> Instruction {cons("DALOAD")}
		"aaload" -> Instruction {cons("AALOAD")}

		"iastore" -> Instruction {cons("IASTORE")}
		"lastore" -> Instruction {cons("LASTORE")}
		"bastore" -> Instruction {cons("BASTORE")}
		"castore" -> Instruction {cons("CASTORE")}
		"sastore" -> Instruction {cons("SASTORE")}
		"fastore" -> Instruction {cons("FASTORE")}
		"dastore" -> Instruction {cons("DASTORE")}
		"aastore" -> Instruction {cons("AASTORE")}
		
		"arraylength" -> Instruction {cons("ARRAYLENGTH")}
		
		"checkcast" ClassRef  -> Instruction {cons("CHECKCAST")}
		"instanceof" ClassRef -> Instruction {cons("INSTANCEOF")}
    
    
	lexical restrictions
		
		"new"
		"newarray"
		"anewarray"
		"multianewarray"
		"getfield"
		"putfield"
		"getstatic"
		"putstatic"
		"checkcast"
		"instanceof"-/- ~[\ \t]

module instructions/JasminXT-Conversion

exports
	
	context-free syntax
		
		"i2l" -> Instruction {cons("I2L")}
		"i2f" -> Instruction {cons("I2F")}
		"i2d" -> Instruction {cons("I2D")}
		"l2f" -> Instruction {cons("L2F")}
		"l2d" -> Instruction {cons("L2D")}
		"f2d" -> Instruction {cons("F2D")}
		
		"int2byte" 	-> Instruction {cons("I2B")} %% TODO: recover i2b, i2s, i2c
		"int2short" -> Instruction {cons("I2S")}
		"int2char" 	-> Instruction {cons("I2C")}
		
		"l2i" -> Instruction {cons("L2I")}
		"f2i" -> Instruction {cons("F2I")}
		"f2l" -> Instruction {cons("F2L")}
		"d2i" -> Instruction {cons("D2I")}
		"d2l" -> Instruction {cons("D2L")}
		"d2f" -> Instruction {cons("D2F")}

module instructions/JasminXT-Arithmetic

imports
	
	lexical/JasminXT-Names
	lexical/JasminXT-Numbers
	
exports
	context-free syntax
		
		"iadd" 	-> Instruction {cons("IADD")}
		"iand" 	-> Instruction {cons("IAND")}
		"idiv" 	-> Instruction {cons("IDIV")}
		"imul" 	-> Instruction {cons("IMUL")}
		"ineg" 	-> Instruction {cons("INEG")}
		"ior"  	-> Instruction {cons("IOR")}
		"irem" 	-> Instruction {cons("IREM")}
		"ishl" 	-> Instruction {cons("ISHL")}
		"ishr" 	-> Instruction {cons("ISHR")}
		"isub" 	-> Instruction {cons("ISUB")}
		"iushr" -> Instruction {cons("IUSHR")}
		"ixor" 	-> Instruction {cons("IXOR")}
		
		"ladd" 	-> Instruction {cons("LADD")}
		"land" 	-> Instruction {cons("LAND")}
		"ldiv" 	-> Instruction {cons("LDIV")}
		"lmul" 	-> Instruction {cons("LMUL")}
		"lneg" 	-> Instruction {cons("LNEG")}
		"lor" 	-> Instruction {cons("LOR")}
		"lrem" 	-> Instruction {cons("LREM")}
		"lshl" 	-> Instruction {cons("LSHL")}
		"lshr" 	-> Instruction {cons("LSHR")}
		"lsub" 	-> Instruction {cons("LSUB")}
		"lushr" -> Instruction {cons("LUSHR")}
		"lxor" 	-> Instruction {cons("LXOR")}
		
		"fadd" 	-> Instruction {cons("FADD")}
		"fdiv" 	-> Instruction {cons("FDIV")}
		"fmul" 	-> Instruction {cons("FMUL")}
		"fneg" 	-> Instruction {cons("FNEG")}
		"frem" 	-> Instruction {cons("FREM")}
		"fsub" 	-> Instruction {cons("FSUB")}

		"dadd" 	-> Instruction {cons("DADD")}
		"ddiv" 	-> Instruction {cons("DDIV")}
		"dmul" 	-> Instruction {cons("DMUL")}
		"dneg" 	-> Instruction {cons("DNEG")}		
		"drem" 	-> Instruction {cons("DREM")}
		"dsub" 	-> Instruction {cons("DSUB")}
		
		"iinc" VarRef Amount -> Instruction {cons("IINC")}
    
    	Int 		-> Amount
    	"-" Int -> Amount {cons("Neg")}
    	
    	"fcmpg" -> Instruction {cons("FCMPG")}
    	"fcmpl" -> Instruction {cons("FCMPL")}
    	
    	"dcmpg" -> Instruction {cons("DCMPG")}
    	"dcmpl" -> Instruction {cons("DCMPL")}
    	
    	"lcmp" 	-> Instruction {cons("LCMP")}
    	
    lexical restrictions
    	
     	"iinc" -/- ~[\ \t]

module instructions/JasminXT-LoadStore

imports
	
	lexical/JasminXT-Names
	lexical/JasminXT-Numbers
	lexical/JasminXT-Strings
	
exports
	
	context-free syntax
		
		"bipush" Int  -> Instruction {cons("BIPUSH")} %% pushes a byte onto the stack as an integer value
		"sipush" Int  -> Instruction {cons("SIPUSH")} %% pushes a signed integer onto the stack
		
		"iconst_m1"	  -> Instruction {cons("ICONST_M1")} %% loads the int value -1 onto the stack
		"iconst_0" 	  -> Instruction {cons("ICONST_0")} %% loads the int value 0 onto the stack
		"iconst_1" 	  -> Instruction {cons("ICONST_1")} %% loads the int value 1 onto the stack
		"iconst_2" 	  -> Instruction {cons("ICONST_2")} %% loads the int value 2 onto the stack
		"iconst_3" 	  -> Instruction {cons("ICONST_3")} %% loads the int value 3 onto the stack
		"iconst_4" 	  -> Instruction {cons("ICONST_4")} %% loads the int value 4 onto the stack
		"iconst_5" 	  -> Instruction {cons("ICONST_5")} %% loads the int value 5 onto the stack
		
		"lconst_0" 	  -> Instruction {cons("LCONST_0")} %% pushes the long 0 onto the stack
		"lconst_1" 	  -> Instruction {cons("LCONST_1")} %% pushes the long 1 onto the stack

		"fconst_0" 	  -> Instruction {cons("FCONST_0")} %% pushes 0.0f on the stack
		"fconst_1" 	  -> Instruction {cons("FCONST_1")} %% pushes 1.0f on the stack
		"fconst_2" 	  -> Instruction {cons("FCONST_2")} %% pushes 2.0f on the stack
		
		"dconst_0"	  -> Instruction {cons("DCONST_0")} %% pushes the constant 0.0 onto the stack
		"dconst_1"	  -> Instruction {cons("DCONST_1")} %% pushes the constant 1.0 onto the stack
		
		"aconst_null" -> Instruction {cons("ACONST_NULL")} %% pushes a null reference onto the stack
		
		"ldc"    Constant -> Instruction {cons("LDC")} 	%% pushes a constant from a constant pool (String, int or float) onto the stack
    "ldc2_w" Constant -> Instruction {cons("LDC2_W")} %% pushes a constant from a constant pool (double or long) onto the stack
				
	context-free syntax
		
		"iload" VarRef -> Instruction {cons("ILOAD")} %% loads an int value from a local variable
		"lload" VarRef -> Instruction {cons("LLOAD")} %% loads a long value from a local variable
		"fload" VarRef -> Instruction {cons("FLOAD")} %% loads a float value from a local variable
		"dload" VarRef -> Instruction {cons("DLOAD")} %% loads a double value from a local variable
		"aload" VarRef -> Instruction {cons("ALOAD")} %% loads a reference from a local variable
		
		"iload_0" -> Instruction {cons("ILOAD_0")} 
		"iload_1" -> Instruction {cons("ILOAD_1")} 
		"iload_2" -> Instruction {cons("ILOAD_2")} 
		"iload_3" -> Instruction {cons("ILOAD_3")} 

		"aload_0" -> Instruction {cons("ALOAD_0")} 
		"aload_1" -> Instruction {cons("ALOAD_1")} 
		"aload_2" -> Instruction {cons("ALOAD_2")} 
		"aload_3" -> Instruction {cons("ALOAD_3")} 
		
		"lload_0" -> Instruction {cons("LLOAD_0")} 
		"lload_1" -> Instruction {cons("LLOAD_1")} 
		"lload_2" -> Instruction {cons("LLOAD_2")} 
		"lload_3" -> Instruction {cons("LLOAD_3")} 

		"dload_0" -> Instruction {cons("DLOAD_0")} 
		"dload_1" -> Instruction {cons("DLOAD_1")} 
		"dload_2" -> Instruction {cons("DLOAD_2")} 
		"dload_3" -> Instruction {cons("DLOAD_3")} 
		
		"fload_0" -> Instruction {cons("FLOAD_0")} 
		"fload_1" -> Instruction {cons("FLOAD_1")} 
		"fload_2" -> Instruction {cons("FLOAD_2")} 
		"fload_3" -> Instruction {cons("FLOAD_3")} 

		"istore" VarRef -> Instruction {cons("ISTORE")} %% stores an int value into a local variable
		"lstore" VarRef -> Instruction {cons("LSTORE")} %% stores a long value into a local variable
		"fstore" VarRef -> Instruction {cons("FSTORE")} %% stores a float value into a local variable
		"dstore" VarRef -> Instruction {cons("DSTORE")} %% stores a double value into a local variable
		"astore" VarRef -> Instruction {cons("ASTORE")} %% stores a reference into a local variable

		"istore_0" -> Instruction {cons("ISTORE_0")} 
		"istore_1" -> Instruction {cons("ISTORE_1")} 
		"istore_2" -> Instruction {cons("ISTORE_2")} 
		"istore_3" -> Instruction {cons("ISTORE_3")} 

		"astore_0" -> Instruction {cons("ASTORE_0")} 
		"astore_1" -> Instruction {cons("ASTORE_1")} 
		"astore_2" -> Instruction {cons("ASTORE_2")} 
		"astore_3" -> Instruction {cons("ASTORE_3")} 
		
		"lstore_0" -> Instruction {cons("LSTORE_0")} 
		"lstore_1" -> Instruction {cons("LSTORE_1")} 
		"lstore_2" -> Instruction {cons("LSTORE_2")} 
		"lstore_3" -> Instruction {cons("LSTORE_3")} 

		"fstore_0" -> Instruction {cons("FSTORE_0")} 
		"fstore_1" -> Instruction {cons("FSTORE_1")} 
		"fstore_2" -> Instruction {cons("FSTORE_2")} 
		"fstore_3" -> Instruction {cons("FSTORE_3")} 
		
		"dstore_0" -> Instruction {cons("DSTORE_0")} 
		"dstore_1" -> Instruction {cons("DSTORE_1")} 
		"dstore_2" -> Instruction {cons("DSTORE_2")} 
		"dstore_3" -> Instruction {cons("DSTORE_3")} 

	lexical restrictions
		
		"iload"
		"lload"
		"fload"
		"dload"
		"aload"
		"istore"
		"lstore"
		"fstore"
		"dstore"
		"astore" -/- ~[\ \t]

module instructions/JasminXT-Instructions

imports

	instructions/JasminXT-LoadStore
	instructions/JasminXT-Arithmetic
	instructions/JasminXT-Conversion
	instructions/JasminXT-Objects
	instructions/JasminXT-Stack
	instructions/JasminXT-Control
	instructions/JasminXT-Methods
	instructions/JasminXT-Exceptions
	instructions/JasminXT-Synchronisation
	
exports
	context-free syntax
		
		"nop" 		 -> Instruction {cons("NOP")}
		"breakpoint" -> Instruction {cons("BREAKPOINT")}

		Int ":" Instruction -> PCInstruction {cons("PC")}
		Instruction 				-> PCInstruction

module JasminXT-Methods

imports
	
	lexical/JasminXT-Names
	lexical/JasminXT-Numbers
	lexical/JasminXT-Strings
	lexical/JasminXT-Descriptors
	
	instructions/JasminXT-Instructions
	JasminXT-Directives
	
exports
	
	context-free syntax
		
 		".method" 
 		MethodAccess* 
 		MethodName 
 		MethodDescriptor 
 		Statement*
 		".end" "method" -> Method {cons("JBCMethod"), scope(Label)}
				
 		"public" 				-> MethodAccess {cons("PUBLIC")}
 		"private" 			-> MethodAccess {cons("PRIVATE")}
 		"protected"		 	-> MethodAccess {cons("PROTECTED")}
 		"static" 				-> MethodAccess {cons("STATIC")}
 		"final"					-> MethodAccess {cons("FINAL")}
 		"synchronized"	-> MethodAccess {cons("SYNCHRONIZED")}
 		"native"				-> MethodAccess {cons("NATIVE")}
 		"abstract"			-> MethodAccess {cons("ABSTRACT")}
 		
 	context-free syntax %% statements
 		
 		PCInstruction -> Statement
 		Directive			-> Statement
 		Label					-> Statement
 		%%	Error		-> Statement
 	
 		LabelName ":"	-> Label {cons("JBCLabel")}
 		
 	lexical restrictions
 		
 		".method" 
 		".end" 
 		"public" 
 		"private"
 		"protected"
 		"static" 	
 		"final"		
 		"synchronized"
 		"native"		
 		"abstract"		-/- ~[\ \t]

module JasminXT-Fields

imports
	
	lexical/JasminXT-Names
	lexical/JasminXT-Numbers
	lexical/JasminXT-Strings
	lexical/JasminXT-Descriptors
	lexical/JasminXT-Signatures
	
exports
	
	context-free syntax
			
		".field" 
		FieldAccess* 
		FieldName 
		FieldDescriptor 
		FieldSignatureSpec
		InitialValue 		-> Field {cons("JBCField")}
	
		".field" 
		FieldAccess* 
		FieldName 
		FieldDescriptor 
		InitialValue 
		FieldExt*
		".end" "field"		-> Field {cons("JBCExtField")}
		
		".signature" FieldSignature 	-> FieldExt {cons("JBCSignature")}
		".deprecated"  					-> FieldExt {cons("JBCDeprecated")}
		%%TODO add .attribute and .annotation

		"signature" FieldSignature	-> FieldSignatureSpec {cons("FieldSig")}
									-> FieldSignatureSpec {cons("None")}
									
		"=" Constant	-> InitialValue {cons("InitVal")}
						-> InitialValue {cons("None")}
		
			
 		"public" 		-> FieldAccess {cons("PUBLIC")}
 		"private" 		-> FieldAccess {cons("PRIVATE")}
 		"protected" 	-> FieldAccess {cons("PROTECTED")}
 		"static" 		-> FieldAccess {cons("STATIC")}
 		"final"			-> FieldAccess {cons("FINAL")}
 		"volatile"		-> FieldAccess {cons("VOLATILE")}
 		"transient"		-> FieldAccess {cons("TRANSIENT")}
 		
 	lexical restrictions
			
		".field" 
		".end"
		".signature" 
		".deprecated"
		"signature"
		"public" 	
 		"private" 	
 		"protected" 
 		"static" 	
 		"final"		
 		"volatile"	
 		"transient"	-/- ~[\ \t]

module lexical/JasminXT-Signatures

imports 
	
	lexical/JasminXT-Strings
	lexical/JasminXT-Descriptors
	
exports
	
	lexical syntax
		
		String -> ClassSignature
		String -> FieldSignature
		

module lexical/JasminXT-Descriptors

imports lexical/JasminXT-Names

exports 

	%% Chapter 4	: The class File Format
	%% Section 4.3	: Descriptors
	
	context-free syntax
		
		FieldType 	-> FieldDescriptor 			{cons("JBCFieldDesc")}	
		
		FieldType		-> ParameterDescriptor	
		FieldType 	-> ReturnDescriptor
		"V"					-> ReturnDescriptor 		{cons("Void")}

		BaseType		-> FieldType
		ObjectType	-> FieldType
		ArrayType		-> FieldType

		"B" 				-> BaseType {cons("Byte")}
		"C" 				-> BaseType {cons("Char")}
		"D" 		 		-> BaseType {cons("Double")}
		"F" 		 		-> BaseType {cons("Float")}
		"I" 		 		-> BaseType {cons("Int")}
		"J" 		 		-> BaseType {cons("Long")}
		"S" 		 		-> BaseType {cons("Short")}
		"Z" 		 		-> BaseType {cons("Boolean")}

		FieldType		-> ComponentType
		
	syntax %% avoid whitespaces in method descriptors, reference types, array types
		
		"(" <ParameterDescriptor-CF>* ")" <ReturnDescriptor-CF> -> <MethodDescriptor-CF> {cons("JBCMethodDesc")}
				
		"L" <ClassRef-CF> ";"		-> <ObjectType-CF> {cons("Reference")}	
		"[" <ComponentType-CF> 	-> <ArrayType-CF>  {cons("Array")}

module lexical/JasminXT-Strings

exports
	
	lexical syntax
		
		'"' StringChar* '"' 	-> String
    	
		~[\"\\\n\r]						-> StringChar
    [\\] [nrtfb\"\'\\]		-> StringChar
    	
		[\\] 'u' HexDigit HexDigit HexDigit HexDigit	-> StringChar
	
		[0-9a-fA-F] -> HexDigit
		
	context-free syntax
		
		String -> Constant

module lexical/JasminXT-Numbers

exports
	
	lexical syntax
		
		[0-9] [0-9]* 	-> Int
		
	lexical restrictions
		
		Int -/- [0-9]

	context-free syntax
		
		Int -> Constant

module lexical/JasminXT-Names

imports 
	
	lexical/JasminXT-Numbers
	lexical/JasminXT-Descriptors
	
exports
	
	lexical syntax
		
		[A-Za-z] [A-Za-z0-9]* 	-> Identifier
		
		Identifier							-> SQIdentifier
		"'" Identifier "'"			-> SQIdentifier
		
		{Identifier "/"}+ 			-> QualifiedName
		
		~[\=\:\.\"\-\ \t\n\r]+	-> LabelName
		
	lexical restrictions
		
		Identifier 	-/- [a-zA-Z0-9]
		LabelName		-/- ~[\=\:\.\"\-\ \t\n\r]
		
	context-free syntax
		
		QualifiedName -> ClassName
		Identifier		-> FieldName
		Identifier		-> MethodName
		"<init>"			-> MethodName {cons("Init")}
		SQIdentifier	-> VarName
		
	context-free syntax 
		
		ClassName			-> ClassRef {cons("CRef")}
		Int						-> VarRef   {cons("VarNum")}
		%% VarName     		-> VarRef	{"VarRef"}
		LabelName 		-> LabelRef {cons("LabelRef")}
		
		FieldName			-> FRef{cons("FRef")}
		MethodName		-> MRef{cons("MRef")}
		
	syntax
		
		<ClassRef-CF> "/" <FRef-CF> <LAYOUT?-CF> <FieldDescriptor-CF>  -> <FieldRef-CF>	 {cons("JBCFieldRef")}		
		<ClassRef-CF> "/" <MRef-CF> 			 			 <MethodDescriptor-CF> -> <MethodRef-CF> {cons("JBCMethodRef")}

	context-free syntax
		
		"byte" 				-> BaseTypeName {cons("ByteName")}
		"char" 				-> BaseTypeName {cons("CharName")}
		"double" 			-> BaseTypeName {cons("DoubleName")}
		"float"				-> BaseTypeName {cons("FloatName")}
		"int" 				-> BaseTypeName {cons("IntName")}
		"long" 				-> BaseTypeName {cons("LongName")}
		"short"				-> BaseTypeName {cons("ShortName")}
		"boolean"			-> BaseTypeName {cons("BooleanName")}

module JasminXT-Header

imports
	
	lexical/JasminXT-Names
	lexical/JasminXT-Numbers
	lexical/JasminXT-Strings
	lexical/JasminXT-Descriptors
	lexical/JasminXT-Signatures
		
exports

	context-free syntax %% header
			
		BytecodeSpec 
		SourceSpec 
		ClassSpec
		SuperSpec 
		ImplementsSpec*
		SignatureSpec
		EnclosingSpec
		DeprecatedSpec
		%%Annotations
		%%GenericAttributes
		%%DebugExtension		
							-> JasminHeader {cons("JBCHeader")}
			
	context-free syntax
			
		".bytecode" MajorVersion MinorVersion 	-> BytecodeSpec {cons("JBCVersion")}
												-> BytecodeSpec {cons("None")}
		
		Int 	-> MajorVersion {cons("Major")}
 		"." Int	-> MinorVersion {cons("Minor")}
				-> MinorVersion {cons("None")}
		
		".source" String	-> SourceSpec {cons("JBCSource")}
	%%	".source" Word		-> SourceSpec {"Source"}
							-> SourceSpec {cons("None")}
								
	context-free syntax
		
		".class"     ClassAccess* ClassName -> ClassSpec {cons("JBCClass")}
		".interface" ClassAccess* ClassName -> ClassSpec {cons("JBCInterface")}
		
		"public" 		-> ClassAccess {cons("PUBLIC")}
 		"final" 		-> ClassAccess {cons("FINAL")}
 		"interface"		-> ClassAccess {cons("INTERFACE")}
 		"abstract" 		-> ClassAccess {cons("ABSTRACT")}
 		"super" 		-> ClassAccess {cons("SUPER")}			%% TODO: check this
  	
 		".super" ClassName -> SuperSpec {cons("JBCSuper")}

		".implements" ClassName -> ImplementsSpec {cons("JBCImplements")}
		
 	context-free syntax
 								
		".signature" ClassSignature 	-> SignatureSpec {cons("JBCSignature")}
										-> SignatureSpec {cons("None")}
	
		".enclosing" "method" MethodDescriptor 	-> EnclosingSpec {cons("JBCEnclosing")}
												-> EnclosingSpec {cons("None")}		
	
		".deprecated"	-> DeprecatedSpec {cons("JBCDeprecated")}
						-> DeprecatedSpec {cons("None")}
	
%%		DebugSpec* -> DebugExtension {"Debug"}
		
%%		".debug" Str -> DebugSpec {"Debug"}

	lexical restrictions
		
		".bytecode"
		".source"
		".class"     
		".interface" 
		"public" 
 		"final" 
 		"interface"
 		"abstract" 
 		"super" 	
 		".super" 		
		".implements" 		
		".signature" 
		".enclosing" 
		%%"method"
		".deprecated" -/- ~[\ \t]

module lexical/JasminXT-Whitespace

exports

	lexical syntax
  
		[\ \t\n\r] 													-> LAYOUT
		";" [\n\r] 													-> LAYOUT
		";" [\ \t] ~[\n\r]* ([\n\r] | EOF) 	-> LAYOUT
    
		-> EOF
  
	lexical restrictions
    
		EOF -/- ~[]
 
	context-free restrictions
  
		LAYOUT? -/- [\ \t\n\r]
		LAYOUT? -/- [\;].[\ \t]
		LAYOUT? -/- [\;].[\n\r]

module JasminXT

imports
	
	lexical/JasminXT-Whitespace
	JasminXT-Header
	JasminXT-Fields
	JasminXT-Methods
	
exports

	context-free start-symbols
		Start

	context-free syntax
  
		JasminFile		-> Start 
		
		JasminHeader 
		%%Inners
		Field* 
		Method* -> JasminFile {cons("JBCFile")}